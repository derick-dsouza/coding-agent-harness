<?xml version="1.0" encoding="UTF-8"?>
<!--
  Application Specification Template
  
  This template provides a structured format for defining software project requirements.
  AI agents can parse this format efficiently due to its hierarchical XML structure.
  
  USAGE INSTRUCTIONS:
  1. Replace all {{PLACEHOLDER}} values with your project details
  2. Remove sections that don't apply to your project
  3. Add custom sections as needed following the same structure
  4. Be specific and detailed - more detail leads to better implementation
  5. Use concrete examples where possible
  
  PRINCIPLES:
  - Explicit over implicit: State requirements clearly
  - Hierarchical structure: Group related features together
  - Implementation-focused: Include technical details and constraints
  - Success-oriented: Define clear success criteria
  - Iterative-friendly: Organize by implementation phases
-->

<project_specification>
  
  <!-- ============================================================ -->
  <!-- PROJECT IDENTITY -->
  <!-- ============================================================ -->
  
  <project_name>Agent SDK Auth Extension</project_name>
  
  <overview>
    The Agent SDK Auth Extension project aims to add reliable authentication flows for Codex and Gemini SDKs to make them comparable to the existing Claude implementation. Currently, the Claude Agent SDK uses OAuth token (environment-based) authentication and works correctly; this will remain unchanged.

    The project will implement authentication for Codex and Gemini adapters with CLI-oriented interfaces. When native OAuth authentication is not available for these SDKs, the system will fall back to using CLIProxy with subscription credentials. The adapter registry already supports CLI-oriented Codex, Gemini, Factory Droid, Aider, OpenCode, and Mistral with simulation fallback capabilities.

    Key features include OAuth device code flows where supported, API key authentication as a secondary option, CLIProxy integration as a fallback mechanism, adapter enforcement to block execution when authentication is missing (unless in simulation mode), and comprehensive diagnostic messaging. The implementation will prioritize security by never hardcoding credentials and will ensure all authentication errors provide actionable next steps for users.
  </overview>
  
  
  <!-- ============================================================ -->
  <!-- TECHNOLOGY STACK -->
  <!-- Define all technical components and constraints -->
  <!-- ============================================================ -->
  
  <technology_stack>
    
    <api_authentication>
      - Claude SDK: OAuth token via environment variable (existing implementation, unchanged)
      - Codex SDK: OAuth device code or CLIProxy fallback
      - Gemini SDK: OAuth device code or API key or CLIProxy fallback
      - Environment variables: CODEX_OAUTH_TOKEN, GEMINI_OAUTH_TOKEN, GEMINI_API_KEY, CLI_PROXY_URL
      - Never hardcode credentials
      - Simulation mode bypasses authentication checks
    </api_authentication>
    
    <frontend>
      <framework>Not applicable (CLI tool)</framework>
      <styling>Not applicable (CLI tool)</styling>
      <state_management>Not applicable (CLI tool)</state_management>
      <routing>Not applicable (CLI tool)</routing>
      <ui_libraries>Not applicable (CLI tool)</ui_libraries>
      <additional_tools>
        - Command-line interface libraries
        - Configuration file parsers (YAML)
        - Authentication helpers for OAuth flows
      </additional_tools>
      <port>Not applicable (CLI tool)</port>
    </frontend>
    
    <backend>
      <runtime>Python 3.x</runtime>
      <framework>Agent SDK framework</framework>
      <database>Not applicable (file-based configuration)</database>
      <orm>Not applicable</orm>
      <api_integrations>
        - Codex CLI tool integration
        - Gemini CLI tool integration
        - CLIProxy service integration
        - Existing Claude SDK integration (unchanged)
        - Factory Droid, Aider, OpenCode, Mistral CLI adapters
      </api_integrations>
      <authentication>OAuth token and API key management</authentication>
      <port>Not applicable (CLI tool)</port>
    </backend>
    
    <communication>
      <api_style>CLI command-line interface</api_style>
      <real_time>Not applicable</real_time>
      <data_format>YAML configuration files, JSON for data exchange</data_format>
    </communication>
    
    <infrastructure>
      <deployment>CLI tool installation (pip)</deployment>
      <ci_cd>Not applicable (CLI tool)</ci_cd>
      <monitoring>Logging for authentication flows</monitoring>
      <logging>Standard Python logging with auth flow diagnostics</logging>
    </infrastructure>
    
  </technology_stack>
  
  
  <!-- ============================================================ -->
  <!-- PREREQUISITES & ENVIRONMENT SETUP -->
  <!-- ============================================================ -->
  
  <prerequisites>
    <environment_setup>
      - Install required CLI tools: codex, gemini
      - Environment variables: CODEX_OAUTH_TOKEN, GEMINI_OAUTH_TOKEN, GEMINI_API_KEY, CLI_PROXY_URL
      - Package manager: pip for Python dependencies
      - Optional: CLIProxy service URL for fallback authentication
      - Configuration files: auth_config.yaml for per-SDK settings
      - No database required
      - No port requirements (CLI tool)
    </environment_setup>
    
    <system_requirements>
      - Python 3.8 or higher
      - Codex CLI tool installed
      - Gemini CLI tool installed
      - OS compatibility: Linux, macOS, Windows (WSL)
      - Minimum RAM: 512MB
      - Disk space: 100MB for tool and dependencies
    </system_requirements>
  </prerequisites>
  
  
  <!-- ============================================================ -->
  <!-- CORE FEATURES -->
  <!-- Organize features by functional area with detailed specs -->
  <!-- ============================================================ -->
  
  <core_features>
    
    <authentication_inventory>
      <name>Auth Options Inventory</name>
      <description>Document and research existing authentication flows for all SDKs</description>
      <requirements>
        - Document Claude OAuth flow specifics (environment variable name, token storage location, refresh behavior)
        - Research Codex CLI supported auth modes (device code, OAuth, API key)
        - Identify Codex login command and token storage location
        - Research Gemini CLI supported auth modes (device code, OAuth, API key)
        - Identify Gemini login command and token storage location
        - Create documentation of all findings in auth_inventory.md
      </requirements>
    </authentication_inventory>
    
    <codex_auth_path>
      <name>Codex Authentication Implementation</name>
      <description>Implement authentication flow for Codex SDK with fallback options</description>
      <requirements>
        - Preferred path: CLI/device-code OAuth flow capturing token to CODEX_OAUTH_TOKEN
        - Fallback: CLIProxy via codex.use_cli_proxy config using CLI_PROXY_URL
        - Adapter enforcement: Block execution when both token and proxy are missing (unless simulation mode)
        - Validate token format and expiration before CLI invocation
        - Pass appropriate token/flags to CLI or proxy command
        - Provide clear error messages with actionable steps to fix auth issues
        - Ensure simulation mode bypasses auth checks as designed
        - Add startup message indicating active auth path
      </requirements>
    </codex_auth_path>
    
    <gemini_auth_path>
      <name>Gemini Authentication Implementation</name>
      <description>Implement authentication flow for Gemini SDK with multiple options</description>
      <requirements>
        - Preferred path: CLI/device-code OAuth flow capturing token to GEMINI_OAUTH_TOKEN
        - Secondary option: GEMINI_API_KEY environment variable
        - Fallback: CLIProxy via gemini.use_cli_proxy config using CLI_PROXY_URL
        - Adapter enforcement mirrors Codex (require token/proxy unless simulation)
        - Validate API key format when using API key authentication
        - Handle token expiration gracefully with refresh prompts
        - Same error handling and simulation bypass as Codex
      </requirements>
    </gemini_auth_path>
    
    <shared_auth_utilities>
      <name>Shared Authentication Utilities</name>
      <description>Common helpers for authentication across all SDKs</description>
      <requirements>
        - Add auth resolver helper that reads environment variables and config
        - Optionally invoke CLI login flow when tokens are missing
        - Surface next steps for users when authentication fails
        - Extend config schema with per-SDK auth_type and expected env vars
        - Define fallback order: OAuth → API key → proxy → simulation
        - Normalize diagnostics (which path selected, which env missing, suggested command)
        - Create auth_helper.py module with reusable functions
      </requirements>
    </shared_auth_utilities>
    
    
    <adapter_wiring>
      <name>Adapter Integration</name>
      <description>Wire authentication into existing SDK adapters</description>
      <requirements>
        - Modify Codex adapter to accept auth payload (token/proxy flags)
        - Modify Gemini adapter to accept auth payload (token/proxy flags)
        - Include auth in all CLI invocations for both adapters
        - Ensure simulation mode skips auth checks by design
        - Add startup prints showing active auth path and warnings
        - Pass tokens via environment variables or CLI flags appropriately
      </requirements>
    </adapter_wiring>
    
    <testing>
      <name>Authentication Testing</name>
      <description>Unit tests for authentication resolution matrix</description>
      <requirements>
        - Unit tests for all auth combinations:
          * Token present/missing for each SDK
          * Proxy enabled/disabled
          * Simulation mode on/off
          * API key vs OAuth vs proxy paths
        - Document CLI login steps with expected outputs
        - Proxy smoke tests if CLIProxy is available
        - Test error messages are actionable
        - Test fallback order works correctly
      </requirements>
    </testing>
    
    <documentation>
      <name>Documentation Updates</name>
      <description>Update README and configuration documentation</description>
      <requirements>
        - Update README.md with authentication sections
        - Document environment variables (CODEX_OAUTH_TOKEN, GEMINI_OAUTH_TOKEN, GEMINI_API_KEY, CLI_PROXY_URL)
        - Document CLI login commands for each SDK
        - Create proxy setup guide
        - Add troubleshooting section for common auth issues
        - Note that Claude path remains unchanged
        - Include examples of configuration files
      </requirements>
    </documentation>
    
    <rollout_safety>
      <name>Safe Rollout Strategy</name>
      <description>Ensure safe deployment of authentication features</description>
      <requirements>
        - Default Codex/Gemini to simulation until tokens/proxy configured
        - No changes to Claude authentication behavior
        - Ensure all error messages include exact env/command to fix
        - Add feature flags for enabling auth per SDK
        - Gradual rollout option if needed
        - Monitoring for auth-related errors
      </requirements>
    </adapter_wiring>
  </core_features>
  
  
  <!-- ============================================================ -->
  <!-- DATABASE SCHEMA -->
  <!-- Define all tables/collections with fields and relationships -->
  <!-- ============================================================ -->
  
  <database_schema>
    <configuration_files>
      
      <auth_config>
        <name>auth_config.yaml</name>
        <description>Per-SDK authentication configuration</description>
        <structure>
          - codex:
            * auth_type: oauth|api_key|proxy|simulation
            * use_cli_proxy: boolean
            * oauth:
              - token_env: CODEX_OAUTH_TOKEN
              - login_command: 'codex auth login'
            * proxy:
              - url_env: CLI_PROXY_URL
          - gemini:
            * auth_type: oauth|api_key|proxy|simulation
            * use_cli_proxy: boolean
            * oauth:
              - token_env: GEMINI_OAUTH_TOKEN
              - login_command: 'gemini auth login'
            * api_key:
              - token_env: GEMINI_API_KEY
            * proxy:
              - url_env: CLI_PROXY_URL
          - claude:
            * auth_type: oauth (existing, unchanged)
            * token_env: CLAUDE_API_TOKEN
        </structure>
      </auth_config>
      
      <environment_variables>
        <name>.env</name>
        <description>Environment variables for authentication</description>
        <variables>
          - CODEX_OAUTH_TOKEN: OAuth token for Codex
          - GEMINI_OAUTH_TOKEN: OAuth token for Gemini
          - GEMINI_API_KEY: API key for Gemini
          - CLI_PROXY_URL: Proxy service URL for fallback
          - CLAUDE_API_TOKEN: Existing Claude token (unchanged)
        </variables>
      </environment_variables>
      
    </configuration_files>
    
    <no_database>
      <description>This CLI tool does not use a database. All configuration is stored in YAML files and environment variables.</description>
    </no_database>
  </database_schema>
  
  
  <!-- ============================================================ -->
  <!-- API ENDPOINTS -->
  <!-- Document all API routes with methods and purposes -->
  <!-- ============================================================ -->
  
  <api_endpoints>
    
    <endpoint_group_1>
      <name>{{Resource Name (e.g., Authentication)}}</name>
      <base_path>{{/api/auth}}</base_path>
      <endpoints>
        {{For each endpoint, specify:
        
        - METHOD /path - Description
        - Request body/params
        - Response format
        - Status codes
        - Authentication required
        
        Example:
        - POST /api/auth/login - User login
          Request: { email: string, password: string }
          Response: { token: string, user: User }
          Status: 200 OK, 401 Unauthorized
          Auth: None
        
        - GET /api/auth/me - Get current user
          Request: None
          Response: { user: User }
          Status: 200 OK, 401 Unauthorized
          Auth: Bearer token required
        
        - POST /api/auth/logout - User logout
          Request: None
          Response: { message: string }
          Status: 200 OK
          Auth: Bearer token required
        }}
      </endpoints>
    </endpoint_group_1>
    
    <endpoint_group_2>
      {{Repeat for each resource...}}
    </endpoint_group_2>
    
    <!-- Common endpoint groups:
    
    <authentication>
      /api/auth/login, /logout, /register, /reset-password
    </authentication>
    
    <users>
      CRUD operations for user management
    </users>
    
    <primary_resources>
      CRUD for your main entities
    </primary_resources>
    
    <search>
      /api/search endpoints
    </search>
    
    <file_uploads>
      /api/upload endpoints
    </file_uploads>
    
    <webhooks>
      Endpoints to receive webhook notifications
    </webhooks>
    -->
    
  </api_endpoints>
  
  
  <!-- ============================================================ -->
  <!-- UI/UX DESIGN SPECIFICATIONS -->
  <!-- ============================================================ -->
  
  <ui_layout>
    
    <main_structure>
      {{Describe the overall layout:
      - Header/navigation structure
      - Main content area organization
      - Sidebar(s) if any
      - Footer content
      - Responsive breakpoints
      - Layout behavior on different screen sizes
      
      Example:
      - Fixed header with logo, navigation, and user menu
      - Left sidebar (250px) with collapsible sections
      - Main content area with max-width 1200px, centered
      - Footer with links and copyright
      - Mobile: Hamburger menu, single column layout
      - Tablet: Two column layout
      - Desktop: Three column layout with sidebars
      }}
    </main_structure>
    
    <navigation>
      {{Define navigation structure:
      - Top-level nav items
      - Sub-navigation
      - Mobile navigation pattern
      - Active state indicators
      - Breadcrumbs if applicable
      }}
    </navigation>
    
    <key_screens>
      <screen_1>
        <name>{{Screen Name (e.g., Dashboard)}}</name>
        <description>{{What this screen shows}}</description>
        <layout>
          {{Describe the screen layout:
          - Component arrangement
          - Grid/flexbox structure
          - Interactive elements
          - Data display format
          
          Example for Dashboard:
          - Top row: Summary statistics (4 cards, equal width)
          - Middle: Chart showing trends (full width)
          - Bottom: Recent activity table (full width, paginated)
          - Right sidebar: Quick actions panel
          }}
        </layout>
        <components>
          {{List major components on this screen with behavior}}
        </components>
      </screen_1>
      
      <screen_2>
        {{Repeat for each major screen...}}
      </screen_2>
    </key_screens>
    
    <modals_overlays>
      {{List all modals/dialogs/overlays:
      - Purpose of each modal
      - Trigger actions
      - Content and form fields
      - Primary and secondary actions
      - Dismissal behavior
      
      Example:
      - Create Item Modal
        Triggered by: "New Item" button
        Content: Form with name, description, category fields
        Actions: Save (primary), Cancel (secondary)
        Dismissal: Click outside, ESC key, Cancel button
      }}
    </modals_overlays>
    
  </ui_layout>
  
  
  <!-- ============================================================ -->
  <!-- DESIGN SYSTEM -->
  <!-- Define visual design language -->
  <!-- ============================================================ -->
  
  <design_system>
    
    <color_palette>
      {{Define color scheme:
      
      - Primary: {{#HEX}} - {{Usage description}}
      - Secondary: {{#HEX}} - {{Usage description}}
      - Accent: {{#HEX}} - {{Usage description}}
      - Background: {{#HEX}} (light), {{#HEX}} (dark)
      - Surface: {{#HEX}} (light), {{#HEX}} (dark)
      - Text: {{#HEX}} (light), {{#HEX}} (dark)
      - Borders: {{#HEX}} (light), {{#HEX}} (dark)
      - Success: {{#HEX}}
      - Warning: {{#HEX}}
      - Error: {{#HEX}}
      - Info: {{#HEX}}
      
      Example:
      - Primary: #3B82F6 - Main brand color for buttons, links
      - Background: #FFFFFF (light), #1F2937 (dark)
      - Text: #111827 (light), #F9FAFB (dark)
      }}
    </color_palette>
    
    <typography>
      {{Define typography system:
      
      - Font families (primary, headings, monospace)
      - Font sizes and scale
      - Font weights
      - Line heights
      - Letter spacing
      
      Example:
      - Sans-serif: Inter, system-ui, sans-serif
      - Monospace: 'Fira Code', Monaco, monospace
      - Heading 1: 2.5rem (40px), font-bold, line-height 1.2
      - Heading 2: 2rem (32px), font-semibold, line-height 1.3
      - Body: 1rem (16px), font-normal, line-height 1.5
      - Small: 0.875rem (14px), font-normal, line-height 1.4
      }}
    </typography>
    
    <spacing>
      {{Define spacing scale:
      
      Example using Tailwind scale:
      - xs: 0.25rem (4px)
      - sm: 0.5rem (8px)
      - md: 1rem (16px)
      - lg: 1.5rem (24px)
      - xl: 2rem (32px)
      - 2xl: 3rem (48px)
      
      Usage guidelines:
      - Component internal padding: sm to md
      - Section spacing: lg to xl
      - Page margins: xl to 2xl
      }}
    </spacing>
    
    <components>
      
      <buttons>
        {{Define button styles:
        - Primary: Background, text color, hover state, active state
        - Secondary: Outline style or ghost style
        - Tertiary: Text-only style
        - Icon buttons: Size and styling
        - Button sizes: Small, medium, large
        - Disabled state appearance
        - Loading state (spinner)
        
        Example:
        - Primary: bg-blue-600, text-white, hover:bg-blue-700, 
                   rounded-lg, px-4 py-2, font-medium
        - Secondary: border-2 border-blue-600, text-blue-600,
                     hover:bg-blue-50
        - Disabled: opacity-50, cursor-not-allowed
        }}
      </buttons>
      
      <inputs>
        {{Define input field styles:
        - Text inputs, textareas
        - Select dropdowns
        - Checkboxes and radio buttons
        - Toggles/switches
        - File upload inputs
        - Focus states
        - Error states
        - Disabled states
        
        Example:
        - Text input: border rounded-md px-3 py-2,
                      focus:ring-2 focus:ring-blue-500,
                      error:border-red-500
        }}
      </inputs>
      
      <cards>
        {{Define card component styling:
        - Background, borders, shadows
        - Padding and spacing
        - Hover states if clickable
        - Header, body, footer sections
        }}
      </cards>
      
      <tables>
        {{Define table styling:
        - Header styling
        - Row styling (including alternating rows)
        - Cell padding
        - Borders
        - Hover states
        - Sorting indicators
        }}
      </tables>
      
      <navigation_elements>
        {{Define nav styling:
        - Tab styles
        - Breadcrumb styles
        - Pagination styles
        - Active/selected states
        }}
      </navigation_elements>
      
    </components>
    
    <animations>
      {{Define animation standards:
      
      - Transition duration (fast: 150ms, normal: 300ms, slow: 500ms)
      - Easing functions (ease-in-out, ease-out)
      - Hover transitions
      - Loading animations
      - Page transitions
      - Micro-interactions
      - Motion reduction for accessibility
      
      Example:
      - Button hover: transition-all duration-150 ease-in-out
      - Modal enter: fade-in + scale-up 200ms
      - List item hover: translate-x-2 duration-150
      - Page transition: fade 300ms
      }}
    </animations>
    
    <icons>
      {{Specify icon library and usage:
      - Icon library (Heroicons, Font Awesome, Lucide, etc.)
      - Icon sizes
      - Icon colors (inherit vs. fixed)
      - Usage guidelines
      }}
    </icons>
    
  </design_system>
  
  
  <!-- ============================================================ -->
  <!-- KEY USER INTERACTIONS & WORKFLOWS -->
  <!-- Document important user flows step-by-step -->
  <!-- ============================================================ -->
  
  <key_interactions>
    
    <workflow_1>
      <name>{{Workflow Name (e.g., User Registration)}}</name>
      <description>{{Brief description}}</description>
      <steps>
        {{List each step in the workflow:
        
        1. User action or trigger
        2. System response
        3. UI changes
        4. Validation or processing
        5. Success/error handling
        6. Next state or screen
        
        Example for "Create New Post":
        1. User clicks "New Post" button
        2. Modal opens with empty form
        3. User enters title, content, selects category
        4. User clicks "Save Draft" or "Publish"
        5. Client validates required fields
        6. Form data sent to POST /api/posts
        7. Loading spinner shows on button
        8. Server validates and creates post in database
        9. On success: Modal closes, success toast, redirect to post
        10. On error: Error message shown below relevant field
        }}
      </steps>
      <edge_cases>
        {{List edge cases and how to handle:
        - Network failure during save
        - Validation errors
        - Duplicate entries
        - Permission denied
        - Session expired
        }}
      </edge_cases>
    </workflow_1>
    
    <workflow_2>
      {{Repeat for other key workflows...}}
    </workflow_2>
    
    <!-- Common workflows to document:
    
    - User registration/login
    - Password reset
    - Creating primary entities
    - Editing and updating
    - Deleting with confirmation
    - Search and filter
    - File upload
    - Sharing/collaboration
    - Payment processing
    - Email verification
    - Multi-step forms
    -->
    
  </key_interactions>
  
  
  <!-- ============================================================ -->
  <!-- IMPLEMENTATION PHASES -->
  <!-- Break down development into logical, sequential phases -->
  <!-- ============================================================ -->
  
  <implementation_steps>
    
    <phase number="1">
      <title>Auth Options Inventory (Research)</title>
      <description>Document existing authentication flows and research new SDK requirements</description>
      <tasks>
        - Document Claude OAuth flow specifics (environment variable name, file outputs, refresh behavior)
        - Check Codex CLI: supported auth modes (device code/OAuth/API key)
        - Identify Codex login command and token storage location
        - Check Gemini CLI: supported auth modes
        - Identify Gemini login command and token storage location
        - Create auth_inventory.md with all findings
      </tasks>
      <dependencies>None</dependencies>
      <deliverables>
        - Complete documentation of Claude auth flow
        - Research findings for Codex auth capabilities
        - Research findings for Gemini auth capabilities
        - Auth inventory markdown file
      </deliverables>
    </phase>
    
    <phase number="2">
      <title>Codex Auth Path</title>
      <description>Implement authentication flow for Codex SDK with CLIProxy fallback</description>
      <tasks>
        - Implement CLI/device-code OAuth flow for Codex
        - Capture token into CODEX_OAUTH_TOKEN environment variable
        - Enable CLIProxy fallback with codex.use_cli_proxy config
        - Implement CLIProxy integration using CLI_PROXY_URL
        - Add adapter enforcement to block when token/proxy missing (unless simulation)
        - Validate token format and expiration before CLI invocation
        - Pass appropriate token/flags to CLI or proxy command
        - Add clear error messages with actionable steps
      </tasks>
      <dependencies>Phase 1 complete</dependencies>
      <deliverables>
        - Working Codex OAuth authentication
        - CLIProxy fallback implementation
        - Adapter enforcement logic
        - Error handling with actionable messages
      </deliverables>
    </phase>
    
    <phase number="3">
      <title>Gemini Auth Path</title>
      <description>Implement authentication flow for Gemini SDK with multiple options</description>
      <tasks>
        - Implement CLI/device-code OAuth flow for Gemini
        - Capture token into GEMINI_OAUTH_TOKEN environment variable
        - Add GEMINI_API_KEY as secondary auth option
        - Implement CLIProxy fallback via gemini.use_cli_proxy config
        - Mirror Codex adapter enforcement logic
        - Add API key format validation
        - Handle token expiration with refresh prompts
      </tasks>
      <dependencies>Phase 2 complete</dependencies>
      <deliverables>
        - Working Gemini OAuth authentication
        - API key authentication option
        - CLIProxy fallback implementation
        - Token expiration handling
      </deliverables>
    </phase>
    
    <phase number="4">
      <title>Shared Auth Utilities</title>
      <description>Create common authentication helpers and extend configuration</description>
      <tasks>
        - Add shared auth resolver helper
        - Implement environment variable reading logic
        - Add optional CLI login flow invocation
        - Extend defaults/config schema with per-SDK auth settings
        - Define fallback order: OAuth → API key → proxy → simulation
        - Normalize diagnostics (selected path, missing env, suggested commands)
        - Store implementation in src/auth/auth_helper.py
      </tasks>
      <dependencies>Phase 3 complete</dependencies>
      <deliverables>
        - Auth resolver helper module
        - Updated configuration schema
        - Normalized diagnostic messages
        - Authentication utility functions
      </deliverables>
    </phase>
    
    <phase number="5">
      <title>Adapter Wiring</title>
      <description>Integrate authentication into existing SDK adapters</description>
      <tasks>
        - Modify Codex adapter to accept auth payload
        - Modify Gemini adapter to accept auth payload
        - Include auth in all CLI invocations
        - Ensure simulation mode skips auth checks
        - Add startup prints showing active auth path
        - Add warnings when falling back to proxy/simulation
        - Pass tokens via environment or CLI flags appropriately
      </tasks>
      <dependencies>Phase 4 complete</dependencies>
      <deliverables>
        - Updated Codex adapter with auth
        - Updated Gemini adapter with auth
        - Auth-aware CLI invocations
        - Startup diagnostic messages
      </deliverables>
    </phase>
    
    <phase number="6">
      <title>Testing</title>
      <description>Unit tests and documentation for authentication flows</description>
      <tasks>
        - Write unit tests for auth resolution matrix
        - Test token present/missing scenarios
        - Test proxy enabled/disabled scenarios
        - Test simulation mode on/off
        - Document CLI login steps with expected outputs
        - Create proxy smoke tests (if available)
        - Test error message actionability
      </tasks>
      <dependencies>Phase 5 complete</dependencies>
      <deliverables>
        - Comprehensive unit test suite
        - Manual integration test documentation
        - Proxy smoke test results
      </deliverables>
    </phase>
    
    <phase number="7">
      <title>Documentation</title>
      <description>Update documentation and create guides</description>
      <tasks>
        - Update README.md with auth sections
        - Document environment variables
        - Document CLI login commands
        - Create proxy setup guide
        - Add troubleshooting section
        - Note Claude path remains unchanged
        - Create configuration examples
      </tasks>
      <dependencies>Phase 6 complete</dependencies>
      <deliverables>
        - Updated README.md
        - Auth configuration guide
        - Troubleshooting documentation
        - Configuration file examples
      </deliverables>
    </phase>
    
    <phase number="8">
      <title>Rollout Safety</title>
      <description>Ensure safe deployment with default behaviors</description>
      <tasks>
        - Default Codex/Gemini to simulation until configured
        - Verify Claude behavior unchanged
        - Ensure errors include exact env/command to fix
        - Add feature flags for per-SDK auth
        - Set up monitoring for auth errors
        - Prepare gradual rollout plan if needed
      </tasks>
      <dependencies>Phase 7 complete</dependencies>
      <deliverables>
        - Safe default configurations
        - Error message verification
        - Feature flag implementation
        - Monitoring setup
      </deliverables>
    </phase>
    
  </implementation_steps>
  
  
  <!-- ============================================================ -->
  <!-- SUCCESS CRITERIA -->
  <!-- Define what "done" looks like -->
  <!-- ============================================================ -->
  
  <success_criteria>
    
    <functionality>
      {{List functional requirements that must work:
      
      - All CRUD operations complete without errors
      - Authentication and authorization working correctly
      - Search returns accurate results
      - File uploads process successfully
      - API endpoints respond within 200ms for common operations
      - Real-time features update without page refresh
      - Forms validate correctly on client and server
      - Error messages are clear and actionable
      
      Be specific and measurable.
      }}
    </functionality>
    
    <user_experience>
      {{Define UX success criteria:
      
      - Interface is intuitive without training
      - Navigation is clear and consistent
      - Feedback is immediate for all actions
      - Loading states prevent confusion
      - Error recovery is smooth
      - Mobile experience is seamless
      - Animations are smooth (60fps)
      - First contentful paint < 1.5s
      
      Focus on observable user experience qualities.
      }}
    </user_experience>
    
    <technical_quality>
      {{Define technical standards:
      
      - Code follows consistent style guide
      - No console errors or warnings
      - All environment variables properly managed
      - Database queries are optimized (< 100ms)
      - No N+1 query problems
      - Proper error handling throughout
      - Security best practices followed
      - API responses are properly typed
      - Test coverage > 80%
      - Build completes without warnings
      
      Include measurable technical metrics.
      }}
    </technical_quality>
    
    <design_polish>
      {{Define visual quality standards:
      
      - Consistent with design system
      - Proper spacing and alignment
      - Responsive on all breakpoints
      - Typography hierarchy clear
      - Colors accessible (WCAG AA)
      - Icons used consistently
      - Animations feel natural
      - Dark mode fully functional
      - No visual bugs or glitches
      
      Focus on visual consistency and polish.
      }}
    </design_polish>
    
    <accessibility>
      {{Define accessibility requirements:
      
      - Keyboard navigation works throughout
      - Screen reader compatible
      - ARIA labels on interactive elements
      - Form labels properly associated
      - Focus indicators visible
      - Color contrast meets WCAG AA
      - Images have alt text
      - Videos have captions
      
      Reference WCAG guidelines.
      }}
    </accessibility>
    
    <performance>
      {{Define performance benchmarks:
      
      - Page load time < 2 seconds
      - Time to interactive < 3 seconds
      - Smooth animations (60fps)
      - API response times < 200ms (p95)
      - Database queries < 100ms (p95)
      - Bundle size < 500KB
      - Lighthouse score > 90
      
      Use measurable metrics.
      }}
    </performance>
    
    <security>
      {{Define security requirements:
      
      - Input validation on all forms
      - SQL injection protection
      - XSS prevention
      - CSRF tokens implemented
      - Sensitive data encrypted
      - API authentication required
      - Rate limiting on endpoints
      - Secure headers configured
      - Dependencies audited (no critical vulnerabilities)
      
      Reference OWASP guidelines.
      }}
    </security>
    
  </success_criteria>
  
  
  <!-- ============================================================ -->
  <!-- TESTING STRATEGY -->
  <!-- Optional but recommended -->
  <!-- ============================================================ -->
  
  <testing_strategy>
    
    <unit_tests>
      {{Define unit testing approach:
      - Utility functions
      - Business logic
      - API route handlers
      - Database models
      - Target coverage percentage
      }}
    </unit_tests>
    
    <integration_tests>
      {{Define integration testing:
      - API endpoint testing
      - Database operations
      - Third-party integrations
      - Authentication flows
      }}
    </integration_tests>
    
    <end_to_end_tests>
      {{Define E2E testing:
      - Critical user workflows
      - Testing tools (Playwright, Cypress)
      - Test scenarios to cover
      }}
    </end_to_end_tests>
    
    <manual_testing>
      {{Define manual testing checklist:
      - Browser compatibility (Chrome, Firefox, Safari, Edge)
      - Device testing (mobile, tablet, desktop)
      - Accessibility testing
      - Visual regression testing
      }}
    </manual_testing>
    
  </testing_strategy>
  
  
  <!-- ============================================================ -->
  <!-- DEPLOYMENT & INFRASTRUCTURE -->
  <!-- Optional but recommended for production apps -->
  <!-- ============================================================ -->
  
  <deployment>
    
    <hosting>
      {{Define hosting requirements:
      - Platform (Vercel, Netlify, AWS, Railway, etc.)
      - Server specifications
      - Scaling strategy
      - CDN requirements
      }}
    </hosting>
    
    <ci_cd>
      {{Define CI/CD pipeline:
      - Build process
      - Test execution
      - Deployment triggers
      - Environment management (dev, staging, prod)
      }}
    </ci_cd>
    
    <monitoring>
      {{Define monitoring and observability:
      - Error tracking (Sentry)
      - Performance monitoring (DataDog, New Relic)
      - Uptime monitoring
      - Log aggregation
      - Alerting strategy
      }}
    </monitoring>
    
    <backup_recovery>
      {{Define backup strategy:
      - Database backup frequency
      - Backup retention policy
      - Recovery procedure
      - Disaster recovery plan
      }}
    </backup_recovery>
    
  </deployment>
  
  
  <!-- ============================================================ -->
  <!-- DOCUMENTATION -->
  <!-- Optional: Define documentation requirements -->
  <!-- ============================================================ -->
  
  <documentation>
    
    <technical_docs>
      {{List technical documentation to create:
      - API documentation (Swagger/OpenAPI)
      - Database schema documentation
      - Architecture diagrams
      - Setup and installation guide
      - Development workflow guide
      - Deployment guide
      }}
    </technical_docs>
    
    <user_docs>
      {{List user documentation to create:
      - User manual or help center
      - Feature guides
      - FAQ
      - Video tutorials
      - Onboarding materials
      }}
    </user_docs>
    
  </documentation>
  
  
  <!-- ============================================================ -->
  <!-- CONSTRAINTS & CONSIDERATIONS -->
  <!-- Optional: Document limitations and special considerations -->
  <!-- ============================================================ -->
  
  <constraints>
    
    <technical_constraints>
      {{List technical limitations:
      - Browser support requirements
      - Performance constraints
      - Scalability limits
      - Third-party API rate limits
      - Budget constraints
      }}
    </technical_constraints>
    
    <business_constraints>
      {{List business limitations:
      - Timeline requirements
      - Resource availability
      - Regulatory compliance (GDPR, HIPAA, etc.)
      - Licensing restrictions
      }}
    </business_constraints>
    
    <out_of_scope>
      {{Explicitly list what is NOT included:
      - Features to defer to later phases
      - Integrations not in scope
      - Platforms not supported
      - Known limitations
      }}
    </out_of_scope>
    
  </constraints>
  
  
  <!-- ============================================================ -->
  <!-- FUTURE ENHANCEMENTS -->
  <!-- Optional: Document future roadmap items -->
  <!-- ============================================================ -->
  
  <future_enhancements>
    {{List potential future features:
    
    - Feature ideas for v2
    - Experimental features to explore
    - Technical debt to address
    - Scalability improvements
    - New integrations to add
    
    This helps maintain focus on current scope while capturing future ideas.
    }}
  </future_enhancements>
  
</project_specification>
